/*
 * User and Authentication Backend
 *
 * # API for authentication and managing user accounts  This is the API of the service at P7M that manages tenants, accounts and authentication. It is the basis of many services of P7M.  For most endpoints, the caller has to be authenticated with the system and provide a JWT token in the Authorization header of the HTTP request. If your interacting with this API using the Swagger interface, you need to set the JWT token by clicking on the **Authorize** button on the right side of the header. As the value don't forget that the Authorization header starts with the fixed value `Bearer` followed by a space followed by the actual JWT token value.  If anything is unclear or you found a bug in the documentation, please contact <tech@p7m.de>. 
 *
 * The version of the OpenAPI document: 0.11.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method [`login_authorize_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LoginAuthorizePostError {
    Status401(crate::models::AuthorizationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`login_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LoginPostError {
    Status401(crate::models::PasswordLoginResponse),
    UnknownValue(serde_json::Value),
}


/// # Authorize access to a given tenant and get JWT for that access  After the user has been authenticated with the a request to `/login` he got a JWT that is authorized to access the tenant the user belongs to. To access data of other tenants that are also accessible by the authenticated user, a request to this endpoint is required giving the ID of the tenant, that should get accessed. If the user has access to the data of the requested tenant, this endpoint will return another JWT, that can be used to access the data of the desired tenant. 
pub async fn login_authorize_post(configuration: &configuration::Configuration, authorization_request: crate::models::AuthorizationRequest) -> Result<crate::models::AuthorizationResponse, Error<LoginAuthorizePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/login/authorize", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&authorization_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<LoginAuthorizePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// # Authenticate (= proof who you are) to the system using a username and password  This is the first step for interacting with most of the functionality of P7M: the person interacting with the APIs has to authenticate to the system, so that the system knows who is accessing the system.  After authenticating, you automatically get a JWT that is authorized (= granted access) to work within the tenant, the authenticated user belongs to. If you want to access data of a different tenant, that is also accessible by the user, you have to get another JWT that is authorized (= granted access) to the other tenant. This can be done by following this request with an [authorization request](#/Auth/post_login_authorize) (see `/login/authorize`). 
pub async fn login_post(configuration: &configuration::Configuration, password_login_attempt: crate::models::PasswordLoginAttempt) -> Result<crate::models::PasswordLoginResponse, Error<LoginPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/login", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&password_login_attempt);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<LoginPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

