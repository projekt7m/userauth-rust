/*
 * User and Authentication Backend
 *
 * # API for authentication and managing user accounts  This is the API of the service at P7M that manages tenants, accounts and authentication. It is the basis of many services of P7M.  The caller has to be authenticated with the system and provide a JWT token in the Authorization header of the HTTP request. When using the API you typically get this token by authenticating first with OAuth 2.0.  When you are trying this API using the Swagger interface, you need to click the `Authorize` button and then again the Authorize button in the pop-up that gets opened.
 *
 * The version of the OpenAPI document: 0.13.0
 * Contact: tech@p7m.de
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method [`post_login`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostLoginError {
    Status401(crate::models::PasswordLoginResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_login_authorize`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostLoginAuthorizeError {
    Status401(crate::models::AuthorizationResponse),
    UnknownValue(serde_json::Value),
}


/// Authenticate (= proof who you are) to the system using a username and password  This is the first step for interacting with most of the functionality of P7M: the person interacting with the APIs has to authenticate to the system, so that the system knows who is accessing the system.  After authenticating, you automatically get a JWT that is authorized (= granted access) to work within the tenant, the authenticated user belongs to. If you want to access data of a different tenant, that is also accessible by the user, you have to get another JWT that is authorized (= granted access) to the other tenant. This can be done by following this request with an authorization request (see `/login/authorize`).  **Note:** This endpoint is deprecated, use OAuth 2.0 login instead.
pub async fn post_login(configuration: &configuration::Configuration, password_login_attempt: crate::models::PasswordLoginAttempt) -> Result<crate::models::PasswordLoginResponse, Error<PostLoginError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/login", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&password_login_attempt);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PostLoginError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Authorize access to a given tenant and get JWT for that access  After the user has been authenticated with a request to `/login` he got a JWT that is authorized to access the tenant the user belongs to. To access data of other tenants that are also accessible by the authenticated user, a request to this endpoint is required giving the ID of the tenant, that should get accessed. If the user has access to the data of the requested tenant, this endpoint will return another JWT, that can be used to access the data of the desired tenant.  **Note**: This endpoint is deprecated, use OAuth 2.0 login instead. While loggin in the user can select the tenant it wants to work within.
pub async fn post_login_authorize(configuration: &configuration::Configuration, authorization_request: crate::models::AuthorizationRequest) -> Result<crate::models::AuthorizationResponse, Error<PostLoginAuthorizeError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/login/authorize", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&authorization_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PostLoginAuthorizeError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

